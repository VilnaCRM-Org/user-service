# OpenAPI Development Reference Guide

**Detailed patterns, step-by-step guides, and examples for developing OpenAPI specifications.**

This document provides comprehensive implementation details referenced from [SKILL.md](SKILL.md). For quick patterns and overview, see the main skill file.

## Architecture Overview

The OpenAPI layer follows a **Processor Pattern** with clear separation of concerns:

```
src/Shared/Application/OpenApi/
├── Builder/              # Schema and parameter builders
├── Factory/              # Endpoint, request, response, and URI parameter factories
├── Processor/            # Spec transformation processors
└── OpenApiFactory.php    # Main coordinator
```

### Key Principles

1. **Single Responsibility**: Each processor/factory handles ONE specific concern
2. **Immutability**: Use `with*()` methods to create new instances instead of mutating
3. **Functional Programming**: Prefer `array_map`, `array_filter`, `array_combine` over loops
4. **Match Expressions**: Use PHP 8 `match` instead of if-else chains for lower complexity
5. **Early Returns**: Use guard clauses and early returns to reduce nesting

## Directory Structure

### Builder/

Contains classes that build OpenAPI schema components:

- **`ContextBuilder`**: Builds request body contexts (application/problem+json)
- **`ArrayContextBuilder`**: Builds array contexts (application/ld+json)
- **`Parameter`**: Value object for parameter data with `Requirement` enum
- **`ParameterSchemaFactory`**: Creates parameter schemas from `Parameter` objects
- **`ResponseBuilder`**: Builds OpenAPI response objects
- **`UriParameterBuilder`**: Builds path parameter objects
- **`Requirement`**: Enum for REQUIRED/OPTIONAL parameter states

### Factory/

Contains factories that create OpenAPI components:

#### Factory/Endpoint/

Endpoint factories create custom API endpoints not generated by API Platform:

- **`EndpointFactoryInterface`**: Interface all endpoint factories must implement
- **`HealthCheckEndpointFactory`**: Creates health check endpoint

**Pattern**: Each endpoint factory modifies the OpenApi object in-place via `createEndpoint(OpenApi $openApi): void`

#### Factory/Request/

Request factories build request body schemas:

- **`CreateCustomerRequestFactory`**: Schema for customer creation
- **`UpdateCustomerRequestFactory`**: Schema for customer updates

#### Factory/Response/

Response factories build response schemas:

- **`ResponseFactoryInterface`**: Interface for response factories
- **`HealthCheckResponseFactory`**: Health check response schema
- **`ServerErrorResponseFactory`**: 500 error response schema
- **`ValidationErrorFactory`**: 422 validation error response schema

#### Factory/UriParameter/

URI parameter factories build path parameters:

- **`UlidUriParameterFactory`**: Base factory for ULID parameters
- **`UlidUriCustomerFactory`**: Customer ULID parameter
- **`UlidUriCustomerStatus`**: Customer status ULID parameter
- **`UlidUriCustomerType`**: Customer type ULID parameter

### Processor/

Processors transform the generated OpenAPI spec:

- **`ParameterDescriptionAugmenter`**: Adds descriptions to query/filter parameters
- **`PathParametersSanitizer`**: Cleans path parameters
- **`PathParameterCleaner`**: Removes deprecated properties from path parameters
- **`IriReferenceTypeFixer`**: Fixes IRI reference types (iri-reference → string with format)
- **`TagDescriptionAugmenter`**: Adds descriptions to OpenAPI tags

### OpenApiFactory.php

Main coordinator that orchestrates all factories and processors:

```php
public function __invoke(array $context = []): OpenApi
{
    $openApi = $this->decorated->__invoke($context);

    foreach ($this->endpointFactories as $endpointFactory) {
        $endpointFactory->createEndpoint($openApi);
    }

    $this->parameterDescriptionAugmenter->augment($openApi);
    $openApi = $this->tagDescriptionAugmenter->augment($openApi);
    $this->iriReferenceTypeFixer->fix($openApi);
    $openApi = $this->pathParametersSanitizer->sanitize($openApi);

    return $openApi;
}
```

## Key Patterns from user-service

### 1. Constants for HTTP Operations

**Problem**: Method chaining creates long, repetitive code
**Solution**: Use a constant and loop

```php
private const OPERATIONS = ['Get', 'Post', 'Put', 'Patch', 'Delete'];

private function processPathItem(PathItem $pathItem): PathItem
{
    foreach (self::OPERATIONS as $operation) {
        $pathItem = $pathItem->{'with' . $operation}(
            $this->processOperation($pathItem->{'get' . $operation}())
        );
    }
    return $pathItem;
}
```

**Benefits**:

- Reduces code duplication
- Lower cyclomatic complexity
- Easier to maintain

### 2. Match Expressions Over If-Else

**Problem**: If-else chains increase cyclomatic complexity
**Solution**: Use PHP 8's `match` expression

```php
// ❌ Bad: High complexity
private function processOperation(?Operation $operation): ?Operation
{
    if ($operation === null) {
        return null;
    }
    if ($operation->getParameters() === []) {
        return $operation;
    }
    return $operation->withParameters(...);
}

// ✅ Good: Lower complexity
private function processOperation(?Operation $operation): ?Operation
{
    return match (true) {
        $operation === null => null,
        $operation->getParameters() === [] => $operation,
        default => $operation->withParameters(...),
    };
}
```

**Benefits**:

- Each match branch counts as 1 complexity (vs 2+ for if-else)
- More readable
- Forces exhaustive handling

### 3. Functional Array Operations

**Problem**: Foreach loops with mutations increase complexity
**Solution**: Use `array_map`, `array_filter`, `array_combine`

```php
// ❌ Bad: Procedural with mutation
private function collectRequired(array $params): array
{
    $required = [];
    foreach ($params as $param) {
        if ($param->isRequired()) {
            $required[] = $param->name;
        }
    }
    return $required;
}

// ✅ Good: Functional
private function collectRequired(array $params): array
{
    return array_values(
        array_map(
            static fn (Parameter $parameter) => $parameter->name,
            array_filter(
                $params,
                static fn (Parameter $parameter) => $parameter->isRequired()
            )
        )
    );
}
```

**Benefits**:

- No mutation
- Lower complexity (filter + map count as 1 each vs foreach with if)
- More declarative

### 4. Static Methods for Pure Functions

**Problem**: Instance methods when no state is needed
**Solution**: Use static methods for pure transformations

```php
// ✅ Good: Static for pure function
private static function augmentParameter(mixed $parameter, array $descriptions): mixed
{
    $paramName = $parameter->getName();
    $description = $parameter->getDescription();
    $hasDescription = $description !== null && $description !== '';

    return match (true) {
        !isset($descriptions[$paramName]) => $parameter,
        $hasDescription => $parameter,
        default => $parameter->withDescription($descriptions[$paramName]),
    };
}
```

**Benefits**:

- Clear that function has no side effects
- Can be tested in isolation
- Signals immutability

### 5. Method Extraction for Complexity Reduction

**Problem**: Methods with too many branches or too long
**Solution**: Extract focused helper methods

```php
// ❌ Bad: 21 lines, complexity 9
private function processContent(Operation $operation): Operation
{
    $content = $operation->getRequestBody()->getContent();
    $modified = false;

    foreach ($content as $mediaType => $mediaTypeObject) {
        if (!isset($mediaTypeObject['schema']['properties'])) {
            continue;
        }
        foreach ($mediaTypeObject['schema']['properties'] as $propName => $propSchema) {
            if (!isset($propSchema['type']) || $propSchema['type'] !== 'iri-reference') {
                continue;
            }
            // mutation logic...
            $modified = true;
        }
    }
    return $modified ? $operation->withRequestBody(...) : $operation;
}

// ✅ Good: 14 lines, complexity 4
private function processContent(Operation $operation): Operation
{
    $requestBody = $operation->getRequestBody();
    $content = $requestBody->getContent();
    $modified = false;

    foreach ($content as $mediaType => $mediaTypeObject) {
        $fixedProperties = $this->fixProperties($mediaTypeObject);
        if ($fixedProperties !== null) {
            $content[$mediaType]['schema']['properties'] = $fixedProperties;
            $modified = true;
        }
    }

    return $modified
        ? $operation->withRequestBody($requestBody->withContent(new ArrayObject($content->getArrayCopy())))
        : $operation;
}

// Extracted method: 15 lines, complexity 4
private function fixProperties(array $mediaTypeObject): ?array
{
    if (!isset($mediaTypeObject['schema']['properties'])) {
        return null;
    }

    $properties = $mediaTypeObject['schema']['properties'];
    $fixedProperties = array_map(
        static fn ($propSchema) => self::fixProperty($propSchema),
        $properties
    );

    return $fixedProperties === $properties ? null : $fixedProperties;
}
```

**Benefits**:

- Each method stays under 20 lines (PHPInsights limit)
- Each method has complexity ≤ 10 (PHPMD limit)
- Better testability
- Clear naming documents intent

### 6. Avoiding empty() for Type Safety

**Problem**: `empty()` is forbidden by PHPInsights
**Solution**: Use explicit type checks

```php
// ❌ Bad: Using empty()
if (empty($parameters)) {
    return $operation;
}
if (empty($parameter->getDescription())) {
    // ...
}

// ✅ Good: Explicit checks
if ($parameters === []) {
    return $operation;
}
$description = $parameter->getDescription();
if ($description === null || $description === '') {
    // ...
}
```

**Benefits**:

- Type-safe
- Clear intent
- Passes PHPInsights

### 7. Delegation Over Implementation

**Problem**: Large classes with many responsibilities
**Solution**: Delegate to specialized classes

```php
// ✅ Good: OpenApiFactory delegates to processors
$this->parameterDescriptionAugmenter->augment($openApi);
$openApi = $this->tagDescriptionAugmenter->augment($openApi);
$this->iriReferenceTypeFixer->fix($openApi);
$openApi = $this->pathParametersSanitizer->sanitize($openApi);
```

**Benefits**:

- Each processor has single responsibility
- Easy to add new processors
- Clear execution pipeline

## How to Add New Components

### Adding a New Processor

1. **Create the processor class**:

```php
// src/Shared/Application/OpenApi/Processor/YourProcessor.php
namespace App\Shared\Application\OpenApi\Processor;

use ApiPlatform\OpenApi\OpenApi;

final class YourProcessor
{
    private const OPERATIONS = ['Get', 'Post', 'Put', 'Patch', 'Delete'];

    public function process(OpenApi $openApi): OpenApi
    {
        foreach (array_keys($openApi->getPaths()->getPaths()) as $path) {
            $pathItem = $openApi->getPaths()->getPath($path);
            $openApi->getPaths()->addPath(
                $path,
                $this->processPathItem($pathItem)
            );
        }
        return $openApi;
    }

    private function processPathItem(PathItem $pathItem): PathItem
    {
        foreach (self::OPERATIONS as $operation) {
            $pathItem = $pathItem->{'with' . $operation}(
                $this->processOperation($pathItem->{'get' . $operation}())
            );
        }
        return $pathItem;
    }

    private function processOperation(?Operation $operation): ?Operation
    {
        return match (true) {
            $operation === null => null,
            // Add your conditions...
            default => $operation,
        };
    }
}
```

2. **Inject it into OpenApiFactory**:

```php
// src/Shared/Application/OpenApi/OpenApiFactory.php
public function __construct(
    private OpenApiFactoryInterface $decorated,
    private iterable $endpointFactories,
    private PathParametersSanitizer $pathParametersSanitizer
        = new PathParametersSanitizer(),
    private YourProcessor $yourProcessor = new YourProcessor(),  // Add here
    // ...
) {}

public function __invoke(array $context = []): OpenApi
{
    $openApi = $this->decorated->__invoke($context);

    // ...
    $openApi = $this->yourProcessor->process($openApi);  // Add here

    return $openApi;
}
```

### Adding a New Endpoint Factory

1. **Create the factory**:

```php
// src/Shared/Application/OpenApi/Factory/Endpoint/YourEndpointFactory.php
namespace App\Shared\Application\OpenApi\Factory\Endpoint;

use ApiPlatform\OpenApi\OpenApi;
use ApiPlatform\OpenApi\Model;

final readonly class YourEndpointFactory implements EndpointFactoryInterface
{
    public function createEndpoint(OpenApi $openApi): void
    {
        $pathItem = new Model\PathItem(
            post: new Model\Operation(
                operationId: 'yourOperation',
                tags: ['YourTag'],
                summary: 'Your endpoint summary',
                description: 'Your endpoint description',
                responses: [
                    '200' => new Model\Response(
                        description: 'Success',
                        content: new \ArrayObject([
                            'application/json' => [
                                'schema' => [
                                    'type' => 'object',
                                    'properties' => [
                                        'status' => ['type' => 'string'],
                                    ],
                                ],
                            ],
                        ])
                    ),
                ],
            )
        );

        $openApi->getPaths()->addPath('/your-endpoint', $pathItem);
    }
}
```

2. **Register in services.yaml**:

```yaml
# config/services.yaml
App\Shared\Application\OpenApi\Factory\Endpoint\YourEndpointFactory:
  tags: ['app.openapi_endpoint_factory']
```

The factory will be auto-discovered and injected into `OpenApiFactory`.

### Adding Parameter Descriptions

1. **Add to ParameterDescriptionAugmenter**:

```php
// src/Shared/Application/OpenApi/Processor/ParameterDescriptionAugmenter.php

private function getYourFilterDescriptions(): array
{
    return [
        'yourParam' => 'Description of your parameter',
        'yourParam[]' => 'Description for array variant',
        'yourParam[nested]' => 'Description for nested parameter',
    ];
}

private function getParameterDescriptions(): array
{
    return array_merge(
        $this->getOrderDescriptions(),
        $this->getFilterDescriptions(),
        $this->getYourFilterDescriptions(),  // Add here
        // ...
    );
}
```

2. **Keep methods under 20 lines**: If a method grows too large, split it into multiple provider methods.

### Adding a New Builder

1. **Create the builder class**:

```php
// src/Shared/Application/OpenApi/Builder/YourBuilder.php
namespace App\Shared\Application\OpenApi\Builder;

final class YourBuilder
{
    public function build(/* parameters */): mixed
    {
        return /* your built object */;
    }
}
```

2. **Use it in factories or processors**:

```php
$yourBuilder = new YourBuilder();
$result = $yourBuilder->build(...);
```

## Complexity Management

### Target Metrics

From PHPInsights configuration:

- **Min Complexity**: 94%
- **Max Cyclomatic Complexity per Method**: 10 (PHPMD threshold)
- **Max Method Length**: 20 lines
- **Max Cyclomatic Complexity per Class**: Aim for ≤ 8

### Techniques to Reduce Complexity

1. **Use Match Instead of If-Else**

   - Each `match` case = 1 complexity
   - Each `if` = +1, each `elseif` = +1

2. **Extract Conditions to Variables**

```php
// ❌ Bad: Complexity 3
if (isset($descriptions[$paramName]) && ($description === null || $description === '')) {
    // ...
}

// ✅ Good: Complexity 2
$hasDescription = $description !== null && $description !== '';
if (isset($descriptions[$paramName]) && !$hasDescription) {
    // ...
}
```

3. **Use Early Returns**

```php
// ❌ Bad: Nested conditions
if ($operation !== null) {
    if ($operation->getParameters() !== []) {
        return $operation->withParameters(...);
    }
}
return $operation;

// ✅ Good: Early returns
if ($operation === null) {
    return null;
}
if ($operation->getParameters() === []) {
    return $operation;
}
return $operation->withParameters(...);
```

4. **Replace Loops with array_map/array_filter**

```php
// ❌ Bad: foreach with if
$result = [];
foreach ($items as $item) {
    if ($item->isValid()) {
        $result[] = $item->transform();
    }
}

// ✅ Good: functional
$result = array_map(
    fn ($item) => $item->transform(),
    array_filter($items, fn ($item) => $item->isValid())
);
```

5. **Split Long Methods**
   - Extract helper methods when over 20 lines
   - Each extracted method should have single responsibility
   - Use descriptive names that document intent

### Common Pitfalls

1. **Don't Mutate OpenApi Objects Directly**

```php
// ❌ Bad: Direct mutation
$operation->parameters[] = $newParameter;

// ✅ Good: Use with methods
$operation = $operation->withParameters(
    array_merge($operation->getParameters(), [$newParameter])
);
```

2. **Don't Use empty()**

```php
// ❌ Bad: Forbidden by PHPInsights
if (empty($array)) { }

// ✅ Good: Explicit check
if ($array === []) { }
```

3. **Don't Create God Classes**

   - Split into multiple processors
   - Each processor = one concern

4. **Don't Forget OPERATIONS Constant**

```php
// ❌ Bad: Repetitive
$pathItem
    ->withGet(...)
    ->withPost(...)
    ->withPut(...)
    ->withPatch(...)
    ->withDelete(...);

// ✅ Good: Loop
foreach (self::OPERATIONS as $operation) {
    $pathItem = $pathItem->{'with' . $operation}(...);
}
```

## Testing Your Changes

### 1. Generate and Validate OpenAPI Spec

```bash
make generate-openapi-spec
make validate-openapi-spec
```

Expected output: `No results with a severity of 'hint' or higher found!`

### 2. Run PHPInsights

```bash
make phpinsights
```

Expected scores:

- Code: 99-100%
- Complexity: ≥94%
- Architecture: 100%
- Style: 100%

### 3. Run Unit Tests

```bash
make unit-tests
```

Expected: All tests pass with 100% coverage

### 4. Check Complexity

```bash
make phpmd
```

Expected: No violations

## Examples from Codebase

### Example 1: ParameterDescriptionAugmenter

Shows all key patterns:

- OPERATIONS constant
- Match expressions
- Functional programming
- Method extraction
- Static pure functions

**Location**: `src/Shared/Application/OpenApi/Processor/ParameterDescriptionAugmenter.php`

**Key Methods**:

- `augmentOperation()`: Uses match expression
- `augmentParameters()`: Uses array_map
- `augmentParameter()`: Static pure function

### Example 2: IriReferenceTypeFixer

Shows complexity reduction:

- Match for null/empty checks
- Extracted `fixProperties()` and `fixProperty()` methods
- array_map for transformation

**Location**: `src/Shared/Application/OpenApi/Processor/IriReferenceTypeFixer.php`

**Complexity Journey**:

- Original: 12 cyclomatic complexity
- After refactoring: 8 cyclomatic complexity

### Example 3: PathParametersSanitizer

Shows delegation pattern:

- Delegates to `PathParameterCleaner`
- Uses OPERATIONS constant
- Match expression for operation processing

**Location**: `src/Shared/Application/OpenApi/Processor/PathParametersSanitizer.php`

## Configuration Files

### phpinsights.php

Key configuration:

```php
'requirements' => [
    'min-quality' => 100,
    'min-complexity' => 94,  // Matches user-service
    'min-architecture' => 100,
    'min-style' => 100,
],
'remove' => [
    // DisallowMixedTypeHintSniff disabled for API Platform's dynamic structures
    SlevomatCodingStandard\Sniffs\TypeHints\DisallowMixedTypeHintSniff::class,
],
```

### phpmd.xml

```xml
<rule name="CyclomaticComplexity">
    <properties>
        <property name="reportLevel" value="10"/>
    </properties>
</rule>
```

## Resources

- **User-Service Reference**: https://github.com/VilnaCRM-Org/user-service/tree/copilot/fix-45
- **API Platform Docs**: https://api-platform.com/docs/
- **OpenAPI 3.1 Spec**: https://spec.openapis.org/oas/v3.1.0
- **Spectral Validation**: https://stoplight.io/open-source/spectral

## Troubleshooting

### "Cyclomatic complexity too high"

- Use match expressions instead of if-else
- Extract methods (keep each under 20 lines)
- Replace loops with array functions
- Extract conditions to variables

### "Function too long"

- Split into helper methods
- Each method should do ONE thing
- Aim for ≤15 lines per method

### "Spectral validation errors"

- Check `.spectral.yaml` for rules
- Ensure all operations have descriptions
- Verify parameter schemas are correct
- Run cleanup script: `python3 scripts/cleanup-openapi-parameters.py`

### "Mixed type hint not allowed"

- Already disabled in phpinsights.php
- If you see this error, verify phpinsights.php configuration

### "Architecture score too low"

- Check Deptrac violations
- Ensure dependencies flow correctly: Infrastructure → Application → Domain
- Don't import Domain into Infrastructure

## Summary Checklist

When contributing to OpenAPI layer:

- [ ] Use OPERATIONS constant for HTTP methods
- [ ] Use match expressions instead of if-else
- [ ] Keep methods under 20 lines
- [ ] Keep cyclomatic complexity under 10
- [ ] Use functional array operations
- [ ] Make pure functions static
- [ ] Avoid empty() - use explicit checks
- [ ] Use early returns and guard clauses
- [ ] Delegate to specialized classes
- [ ] Test with `make validate-openapi-spec`
- [ ] Verify with `make phpinsights`
- [ ] Run `make unit-tests`
